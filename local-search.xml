<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android 测试点总结（长期更新）</title>
    <link href="/2024/07/04/android%E6%B5%8B%E8%AF%95%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2024/07/04/android%E6%B5%8B%E8%AF%95%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-测试点总结"><a href="#Android-测试点总结" class="headerlink" title="Android 测试点总结"></a>Android 测试点总结</h1><p>我们在日常测试Android的时候需要我们注意很多测试点，那么这些也是我慢慢总结的，当然肯定会有落下的，也希望大家可以补充说明，这个帖子是长期更新的帖子不会在新开帖子介绍，欢迎经常来看！</p><h2 id="WebView-的测试"><a href="#WebView-的测试" class="headerlink" title="WebView 的测试"></a>WebView 的测试</h2><p>为什么首先说这个呢？是因为我们现在很多的APP都会有活动的展示，当然WebView不仅仅是活动哈，像一些临时页，改动很频繁的页面等。在测试WebView 我们首先要关注那些点呢？</p><p>1.WebView 在不同机型上的适配情况</p><p>   WebView 在不同的机型上适配情况是我们要关注的，尤其是支持到了小屏手机或者大屏打开的时候，要关注我们主流的要适配的机型，观察页面布局</p><p>   是否正常展示，信息是否遗漏， 按钮是否可以正常点击等！</p><p>2.WebView 呼起Android 内部页面</p><p>  WebView 会含有跳转等，我们要注意若是跳转到APP内部的短链中，需要着重测试一下。</p><p>3.WebView 渲染速度及占用内存</p><p>  WebView 不应该过于复杂，渲染速度应该较快且占用内存小！</p><h2 id="ANR-测试"><a href="#ANR-测试" class="headerlink" title="ANR 测试"></a>ANR 测试</h2><p>  这里可以看我写的ANR 文章里面有很详细的介绍</p><p>  <a href="http://8888666.top/2024/07/03/adroid%E6%B5%8B%E8%AF%95/">http://8888666.top/2024/07/03/adroid%E6%B5%8B%E8%AF%95/</a></p><h2 id="新老版本的测试"><a href="#新老版本的测试" class="headerlink" title="新老版本的测试"></a>新老版本的测试</h2><p>  在测试Andoid的时候尤其要注意新老版本的测试，如果后台发布了新的功能但是只支持新版本，那么就要做版本控制，或者新版本支持老版使用就要看看是否老版能正常使用！</p><h2 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h2><p>  这个老生常谈的话题，覆盖你主流机型测试</p><h2 id="专项测试"><a href="#专项测试" class="headerlink" title="专项测试"></a>专项测试</h2><p>  耗电，耗流， 性能， 打开速度， 发烧 等等标准且这个和公司有关系，不是强制！</p><h2 id="SDK测试"><a href="#SDK测试" class="headerlink" title="SDK测试"></a>SDK测试</h2><p>  如果app使用了三方的sdk 那么我们也是要关注的，不能因为三方的问题导致我们出现了问题</p><h2 id="弱网测试"><a href="#弱网测试" class="headerlink" title="弱网测试"></a>弱网测试</h2><p>  测试APP在弱网情况下的表现，各个公司有不同的标准！</p>]]></content>
    
    
    <categories>
      
      <category>测试常见问题</category>
      
      <category>Android</category>
      
      <category>Android 测试点总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>测试知识</tag>
      
      <tag>Android 测试知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android ANR是什么？</title>
    <link href="/2024/07/03/adroid%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/07/03/adroid%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Android-ANR-是什么呢？"><a href="#Android-ANR-是什么呢？" class="headerlink" title="Android ANR 是什么呢？"></a>Android ANR 是什么呢？</h1><p>在日常测试Android我们会经常听到开发讲述一个专业术语ANR，那么ANR是什么呢？又是什么导致的呢？一起来看看吧！</p><h2 id="什么是ANR？"><a href="#什么是ANR？" class="headerlink" title="什么是ANR？"></a>什么是ANR？</h2><p>ANR,(Application Not Responding) 即应用程序无响应，在android应用中，当我们的UI线程被阻塞，就会弹出如下对话框，用户可以选择继续等待或者关闭这个应用程序,这种现象我们称之为ANR.</p><h2 id="ANR的类型"><a href="#ANR的类型" class="headerlink" title="ANR的类型"></a>ANR的类型</h2><p>一共可以分为三种类型：</p><p>1.主线程对输入事件在5秒内没有处理完毕</p><p>   产生这种ANR的前提是要有输入事件，如果用户没有触发任何输入事件，即便是主线程阻塞了，也不会产生ANR，因为InputDispatcher没有分发事件给应用程序，当然也不会检测处理超时和报告ANR了。</p><p>2.主线程在执行BroadcastReceiver的onReceive函数时10秒内没有执行完毕，后台进程是60秒</p><p>   这种情况的ANR系统不会显示对话框提示，仅是输出log而已。</p><p>3.主线程在执行Service的各个生命周期函数时20秒内没有执行完毕,后台进程为200秒</p><p>   同样对这种情况的ANR系统也不会显示对话框提示，仅是输出log。</p><p>总体来说：</p><table><thead><tr><th>Type</th><th>Method call</th><th>Logsample</th><th>time out</th></tr></thead><tbody><tr><td>Input dispatch</td><td>onClick(),onTouch(),onKeydown(),onKeyup()</td><td>Input dispatching timed out</td><td>5</td></tr><tr><td>Broadcast</td><td>onReceive()</td><td>Timeout of broadcast</td><td>FG: 10, BG 60</td></tr><tr><td>Service</td><td>onBind(),onCreate(),onStartCommand(),onUnbind(),onDestroy()</td><td>Timeout executing service</td><td>FG: 20, BG 200</td></tr></tbody></table><h2 id="ANR产生的原因"><a href="#ANR产生的原因" class="headerlink" title="ANR产生的原因"></a>ANR产生的原因</h2><p>1.应用自身进程引起的问题，比如, 在oncreate ，onstart等生命周期中执行耗时操作，ui线程阻塞，挂起，死循环等</p><p>2.其他进程引起的，比如：io操作导致cpu使用过高，导致当前应用进程无法抢占到cpu时间片</p><h3 id="细分的话可以分为以下一些情况："><a href="#细分的话可以分为以下一些情况：" class="headerlink" title="细分的话可以分为以下一些情况："></a>细分的话可以分为以下一些情况：</h3><p>耗时的网络访问</p><p>大量的数据读写</p><p>数据库操作</p><p>硬件操作（比如camera）</p><p>调用thread的join()方法、sleep()方法、wait()方法或者等待线程锁的时候</p><p>service binder的数量达到上限</p><p>system server中发生WatchDog ANR</p><p>service忙导致超时无响应</p><p>其他线程持有锁，导致主线程等待超时</p><p>其它线程终止或崩溃导致主线程一直等待…</p><h2 id="如何避免ANR"><a href="#如何避免ANR" class="headerlink" title="如何避免ANR"></a>如何避免ANR</h2><p>耗时的工作()比如数据库操作，I&#x2F;O，网络操作，采用单独的工作线程处理</p><p>用Handler来处理UIthread和工作thread的交互</p><p>合理使用 Handler 来处理其他线程请求</p><p>合理使用并遵循 Android 生命周期, 避免在 onCreate() and onResume() 做过多的事情</p><p>使用一些架构形成规范来避免内存等问题,例如：MVP、RxJava</p><p>经常使用工具来检查内存问题,例如:MAT、TraceView、AS 自带等工具</p><p>避免加载大图片引起内存不足导致 ANR</p><p>避免内存泄露引起的 ANR</p>]]></content>
    
    
    <categories>
      
      <category>测试常见问题</category>
      
      <category>Android</category>
      
      <category>Android ANR是什么？</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试知识</tag>
      
      <tag>Android 测试知识</tag>
      
      <tag>原创、转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python url编码</title>
    <link href="/2024/07/03/url%E5%8A%A0%E5%AF%86/"/>
    <url>/2024/07/03/url%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-实现url-编码"><a href="#Python-实现url-编码" class="headerlink" title="Python 实现url 编码"></a>Python 实现url 编码</h1><p>在平常的测试中，我们会遇见在测试某些url 要求传递的是url编码后的信息，那么你可以从本文中学会如何使用url编码。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.parse<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UrlEncode_infor</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">urlencode_infor</span>(<span class="hljs-params">self,data</span>):<br>        s=data<br>        s_re= urllib.parse.quote(s)<br>        <span class="hljs-keyword">return</span> s_re<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    url_encode=UrlEncode_infor()<br>    s=<span class="hljs-string">&#x27;patron:id:generaltoken:1b9554037ee04463beaeabd81573785e&#x27;</span><br>    url_encode.urlencode_infor(s)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python 常见函数</category>
      
      <category>Python url编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
      <tag>yield</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python md5加密</title>
    <link href="/2024/07/03/md5%E5%8A%A0%E5%AF%86/"/>
    <url>/2024/07/03/md5%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-实现md5加密"><a href="#Python-实现md5加密" class="headerlink" title="Python 实现md5加密"></a>Python 实现md5加密</h1><p>平常测试过程中，可能会遇到在测试api的时候需要使用md5加密，在编写测试脚本的时候则需要实现其过程，那么在本文中你可以学会如何使用md5加密。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5<br><span class="hljs-keyword">import</span> os,sys<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Md5_Password</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">do_md5</span>(<span class="hljs-params">self,need_encode</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;md5加密&#x27;&#x27;&#x27;</span><br>        password_md5 = md5()<br>        password_md5.update(need_encode.encode())<br>        pwd_secret = password_md5.hexdigest()<br>        <span class="hljs-keyword">return</span> pwd_secret<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    md5_infor=Md5_Password()<br>    password=<span class="hljs-string">&#x27;123qwe&#x27;</span><br>    md5_infor.do_md5(password)<br></code></pre></td></tr></table></figure><p>当然 你可以实现盐的加密 那就是在加密的时候加入指定的信息即可。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python 常见函数</category>
      
      <category>Python md5加密</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
      <tag>yield</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 常见排序算法</title>
    <link href="/2024/07/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-常见排序算法"><a href="#Python-常见排序算法" class="headerlink" title="Python 常见排序算法"></a>Python 常见排序算法</h1><p>在平常面试中，一般都会遇见让写排序算法的要求，那么基本也就这三种排序算法，大家可以掌握学会！</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>原理： 相邻连个数进行比较，大的下沉，最后一个元素最大</p><p>复杂度： 时间复杂度O(n^2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dlist_sort</span>(<span class="hljs-params">dlist</span>):<br>    <span class="hljs-keyword">if</span> dlist == []:<br>        <span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">else</span>:<br>        dlist_lenght = <span class="hljs-built_in">len</span>(dlist)<br>        <span class="hljs-keyword">for</span> i  <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (<span class="hljs-number">0</span>, dlist_lenght):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span> (i+<span class="hljs-number">1</span>, dlist_lenght):<br>                <span class="hljs-keyword">if</span> dlist[i] &gt; dlist[j]:<br>                    dlist[i],dlist[j] = dlist[j],dlist[i]<br>        <span class="hljs-keyword">return</span> dlist<br><br><br><span class="hljs-built_in">print</span>(dlist_sort([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">53</span>]))<br></code></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>原理： 递归思想， 列表中取出第一个元素作为标准，比第一个小的放左侧，比第一个大的放右侧</p><p>复杂度： 时间复杂度O(nlog2n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">quick_sort</span>(<span class="hljs-params">quick_list</span>):<br>    <span class="hljs-keyword">if</span> quick_list == []:<br>        <span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">else</span>:<br>        first = quick_list[<span class="hljs-number">0</span>]<br>        less = quick_sort([l <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> quick_list[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> l &lt; first])<br>        more = quick_sort([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> quick_list[<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> i &gt;= first])<br>    <span class="hljs-keyword">return</span> less + [first] + more<br><br><br><span class="hljs-built_in">print</span>(quick_sort([<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序，即只需用到O(1)的额外空间的排序，因而在从后向前扫描过程中，找到排序位置后，需要将已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>复杂度：O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">arr</span>): <br>  <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr)): <br>  <br>        key = arr[i] <br>  <br>        j = i-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> j &gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> key &lt; arr[j] : <br>                arr[j+<span class="hljs-number">1</span>] = arr[j] <br>                j -= <span class="hljs-number">1</span><br>        arr[j+<span class="hljs-number">1</span>] = key <br>  <br>  <br>arr = [<span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>] <br>insertionSort(arr) <br><span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;排序后的数组:&quot;</span>) <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)): <br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;%d&quot;</span> %arr[i])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题目搜集</category>
      
      <category>Python 算法题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
      <tag>算法</tag>
      
      <tag>Appium</tag>
      
      <tag>Selenium</tag>
      
      <tag>pytest</tag>
      
      <tag>SQL</tag>
      
      <tag>Redis</tag>
      
      <tag>Nginx</tag>
      
      <tag>用例设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无聊</title>
    <link href="/2024/07/03/%E6%97%A0%E8%81%8A/"/>
    <url>/2024/07/03/%E6%97%A0%E8%81%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="无聊"><a href="#无聊" class="headerlink" title="无聊"></a>无聊</h1><p>有时候会突然觉得无聊</p><p>就是那种感觉什么都没意思</p><p>看看窗外的云，人</p><p>也会思考人的意义</p><p>久而久之</p><p>就形成了规律</p><p>然而</p><p>无聊了这么久</p><p>也未想出抛弃众人都有的之外的意义</p><p>生活依旧如寂静的如死的水面</p><p>偶尔的涟漪</p><p>也未能散出绝美的轮廓</p><img src="/2024/07/03/%E6%97%A0%E8%81%8A/%E6%B6%9F%E6%BC%AA.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>2024年随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>随笔</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jmetrer添加验证点</title>
    <link href="/2024/07/03/jmerer%E6%B7%BB%E5%8A%A0%E9%AA%8C%E8%AF%81%E7%82%B9/"/>
    <url>/2024/07/03/jmerer%E6%B7%BB%E5%8A%A0%E9%AA%8C%E8%AF%81%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Jmetrer添加验证点"><a href="#Jmetrer添加验证点" class="headerlink" title="Jmetrer添加验证点"></a>Jmetrer添加验证点</h1><p>在测试中我们通常都需要有个校验的地方，那么在jmeter中我们可以这样添加验证点</p><h2 id="添加验证点"><a href="#添加验证点" class="headerlink" title="添加验证点"></a>添加验证点</h2><p>选择HTTP请求然后右键选择添加-&gt;断言-&gt;响应断言</p><img src="/2024/07/03/jmerer%E6%B7%BB%E5%8A%A0%E9%AA%8C%E8%AF%81%E7%82%B9/%E9%AA%8C%E8%AF%81%E7%82%B9.png" class=""><p>然后添加断言结果，选择线程组右键-&gt;监听器-&gt;断言结果</p><p>运行后，如果HTTP响应没有包含期待的字符串，那么断言就会失败</p><img src="/2024/07/03/jmerer%E6%B7%BB%E5%8A%A0%E9%AA%8C%E8%AF%81%E7%82%B9/%E9%AA%8C%E8%AF%81%E7%82%B91.png" class="">]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Jmeter</category>
      
      <category>Jmeter 添加验证点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Jmeter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jmeter响应编码异常</title>
    <link href="/2024/07/03/jmerer%E5%93%8D%E5%BA%94%E7%BC%96%E7%A0%81%E5%BC%82%E5%B8%B8/"/>
    <url>/2024/07/03/jmerer%E5%93%8D%E5%BA%94%E7%BC%96%E7%A0%81%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="Jmeter响应编码异常"><a href="#Jmeter响应编码异常" class="headerlink" title="Jmeter响应编码异常"></a>Jmeter响应编码异常</h1><p>当响应数据或响应页面没有设置编码时候，JMeter会按照jmeter.properties文件中的sampleresult.default.encoding设置的格式解析。</p><p>默认为ISO-8859-1,所以解析中文时候肯定会出错，那么我们需要你把编码改为UTF-8.</p><img src="/2024/07/03/jmerer%E5%93%8D%E5%BA%94%E7%BC%96%E7%A0%81%E5%BC%82%E5%B8%B8/%E7%BC%96%E7%A0%81.png" class=""><p>修改完毕后我们需要将”#”去掉，然后重启JMeter</p>]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Jmeter</category>
      
      <category>Jmeter 响应编码异常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Jmeter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jmeter线程组</title>
    <link href="/2024/07/03/jmerer%E7%BA%BF%E7%A8%8B%E7%BB%84/"/>
    <url>/2024/07/03/jmerer%E7%BA%BF%E7%A8%8B%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Jmeter线程组"><a href="#Jmeter线程组" class="headerlink" title="Jmeter线程组"></a>Jmeter线程组</h1><p>在JMeter中，任何类型的测试都需要先创建线程组，一个线程组可以看做一个测试任务</p><h2 id="添加线程组"><a href="#添加线程组" class="headerlink" title="添加线程组"></a>添加线程组</h2><p>鼠标右键单击“测试计划”在快捷键菜单中单击添加-&gt;Threads(Users)-&gt;线程组</p><p>注意：在JMeter中，任何内容都应该放在线程中！</p><img src="/2024/07/03/jmerer%E7%BA%BF%E7%A8%8B%E7%BB%84/jmeter%E7%BA%BF%E7%A8%8B%E7%BB%84.png" class=""><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>1.线程数：一个线程代表一个虚拟用户</p><p>2.Ramp-Up Period(in seconds)：设置线程的启动时长，单位为S，如果线程数是100，启动时长为5s，那么需要5s启动100个线程，平均每秒启动20个线程</p><p>3.循环次数：每个线程发送的请求次数。如果这个线程中有5个HTTP请求，循环次数为3的话，那么一个线程会发送5*3&#x3D;15个HTTP请求。</p><p>4.如果选择了“永远”复选框，那么所有的线程会无限发送请求，直到手动单击工具栏上的停止按钮。</p><p>如果用来做功能测试&#x2F;接口测试，那么应保持默认设置，线程数设置为1，Ramp-up Period(in seconds)设置为1，循环次数也设置为1</p><h2 id="线程组添加HTTP请求"><a href="#线程组添加HTTP请求" class="headerlink" title="线程组添加HTTP请求"></a>线程组添加HTTP请求</h2><img src="/2024/07/03/jmerer%E7%BA%BF%E7%A8%8B%E7%BB%84/http%E8%AF%B7%E6%B1%82.png" class=""><img src="/2024/07/03/jmerer%E7%BA%BF%E7%A8%8B%E7%BB%84/http%E8%AF%B7%E6%B1%821.png" class="">]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Jmeter</category>
      
      <category>Jmeter 线程组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Jmeter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fiddler弱网测试</title>
    <link href="/2024/07/03/fiddler%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/07/03/fiddler%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Fiddler弱网测试"><a href="#Fiddler弱网测试" class="headerlink" title="Fiddler弱网测试"></a>Fiddler弱网测试</h1><p>在我们平常测试中有一种测试叫做弱网测试，也就是要模拟信号较差情况下我们网站的加载情况，那么我们可以利用fillder来轻松实现这个模拟！</p><h2 id="弱网场景"><a href="#弱网场景" class="headerlink" title="弱网场景"></a>弱网场景</h2><p>1.网络慢或延迟，导致加载时间长</p><p>2.网络中断，web服务器返回500等状态码</p><p>3.网络延迟，HTTP请求发出后，很久没有响应</p><h2 id="Fillder-实现弱网"><a href="#Fillder-实现弱网" class="headerlink" title="Fillder 实现弱网"></a>Fillder 实现弱网</h2><p>1.启动Fiddler,选择Rules-&gt;Performances-&gt;Simulate Modem Speeds</p><p>2.打开浏览器，访问网站，你会发现打开网页的速度很慢</p><img src="/2024/07/03/fiddler%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/%E5%BC%B1%E7%BD%911.png" class=""><h2 id="Fillder-精确控制网速"><a href="#Fillder-精确控制网速" class="headerlink" title="Fillder 精确控制网速"></a>Fillder 精确控制网速</h2><p>有时候我们需要精确控制我们的网速具体的速率就可以使用以下方式：</p><p>1.启动Fiddler,选择Rules-&gt;Performances-&gt;Simulate Modem Speeds</p><p>2.在FiddlerScript中找到如下一段代码</p><img src="/2024/07/03/fiddler%E5%BC%B1%E7%BD%91%E6%B5%8B%E8%AF%95/%E8%84%9A%E6%9C%AC.png" class=""><p>我们可以通过修改对应的数值来控制网速</p><p>3.修改完毕后，原本已经勾选的Simulate Modem Speeds会被取消勾选，再次选中Rules-&gt;Performances-&gt;Simulate Modem Speeds</p><p>4.访问浏览器会更加慢<br> <br>网络取值算法就是 1000&#x2F;下载速速&#x3D;需要延迟的时间(ms)，比如50kbit&#x2F;s需要延迟200ms来接收数据</p>]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Fillder</category>
      
      <category>Fillder 弱网测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Fillder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fiddler前端调试</title>
    <link href="/2024/07/03/fiddler%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/"/>
    <url>/2024/07/03/fiddler%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Fiddler前端调试"><a href="#Fiddler前端调试" class="headerlink" title="Fiddler前端调试"></a>Fiddler前端调试</h1><p>有时候我们可能需要在服务器上面调试javaScript文件，但是又比较麻烦，此时为了方便可以使用fillder来实现！</p><h2 id="Fiddler-AutoResponder的工作原理"><a href="#Fiddler-AutoResponder的工作原理" class="headerlink" title="Fiddler AutoResponder的工作原理"></a>Fiddler AutoResponder的工作原理</h2><p>使用Fiddler可以替换自动返回的一个伪造的HTTP响应，者跟之前介绍的下断点修改HTTP响应差不多，只不过AutoResponder是自动的，操作更加方便！</p><h3 id="Fiddler在线调试JavaScript文件"><a href="#Fiddler在线调试JavaScript文件" class="headerlink" title="Fiddler在线调试JavaScript文件"></a>Fiddler在线调试JavaScript文件</h3><p>1.首先我们将JS文件保存到本地</p><p>2.然后编辑本地的JavaScript文件，更改需要编辑的代码</p><p>3.启动Fiddler，在浏览器中打开网址，然后使用Fiddler抓住这个JavaScript的HTTP请求</p><p>4.然后将Fiddler中，的这个JS拖拽到AutoResponser中</p><p>5.在RuleEditor中单击“Find a file…”，选择本地JavaScript文件的路径。</p><p>6.选中”Enable rules”，激活规则，选中”Unmatched requests passthrough”放行不匹配的HTTP请求。</p><p>7.单击“Save”按钮</p><p>8.你只需要修改本地机器上的文件，然后刷新浏览器，就可以看到效果了！</p><p>若是不显示CSS&#x2F;JS等文件信息，可以在Filters—Request Headers勾选Show only if URL contains选项</p><p>填写文件类型：</p><p>REGX:(?insx)&#x2F;[^?&#x2F;]<em>.(css|js|json|ico|jpg|png|gif|bmp|wav)(?.</em>)?$</p><p>然后选择Actions-&gt;Run Filterset Now</p><img src="/2024/07/03/fiddler%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/fillder%E8%B0%83%E8%AF%95.png" class=""><p>替换照片</p><img src="/2024/07/03/fiddler%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/%E6%9B%BF%E6%8D%A2%E7%85%A7%E7%89%87.png" class=""><p>效果</p><img src="/2024/07/03/fiddler%E5%89%8D%E7%AB%AF%E8%B0%83%E8%AF%95/%E6%95%88%E6%9E%9C.png" class="">]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Fillder</category>
      
      <category>Fillder 前端调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Fillder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>完美解决自定义域名访问gitpages出现了部分请求404的问题！</title>
    <link href="/2024/07/02/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/"/>
    <url>/2024/07/02/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="gitpages出现了部分请求404的问题"><a href="#gitpages出现了部分请求404的问题" class="headerlink" title="gitpages出现了部分请求404的问题"></a>gitpages出现了部分请求404的问题</h1><p>最近把我的博客通过自定义域名代理了gitpages， 理由如下：</p><pre><code class="hljs">一方面是因为 github 确实在国内的访问速度太感人了😂😂😂! 另一方面也是手里有闲置的域名。</code></pre><p>所以就准备搞一下，采用的模式就是 域名 + cloudfare 的模式进行解析，但是在成功后发现部分请求出现了404的情况，如下图：</p><img src="/2024/07/02/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/404%E6%83%85%E5%86%B5.png" class=""><h2 id="为了解决这个问题花费了太多时间"><a href="#为了解决这个问题花费了太多时间" class="headerlink" title="为了解决这个问题花费了太多时间"></a>为了解决这个问题花费了太多时间</h2><p>之前我访问我的gitpages 域名：<a href="https://dreamshao.github.io/xingblog.github.io/">https://dreamshao.github.io/xingblog.github.io/</a>  一直是可以的所有的请求都是正常的，</p><p>可是这次我部署到个人域名后我就发现这怎么部分请求可以拿到，部分请求就是404呢？</p><p>然后，我就开始纠结是不是我在设置自定义域名的时候出现了问题，从开始的域名解析设置 在阿里云上我改了很多次(此时把DNS解析改回了阿里的)，</p><p>发现还是不行，我就想是不是我这个没有备案呢？ 我就开始改回了 cloudfare 的DNS解析，开始在cloudfare 上开始鼓捣，可是鼓捣了很久还是不行</p><p>后来，我就开始在网上查资料，查了好久也没查到为什么部分请求是404，这就花费了我将近1天的时间在上面！</p><h2 id="突然的灵感来临"><a href="#突然的灵感来临" class="headerlink" title="突然的灵感来临"></a>突然的灵感来临</h2><p>第二天早上，我还是打开了我的网站看404的请求，突然想是不是因为我的域名后面不能包含我的子仓库地址呢？ </p><p>之前我的访问路径是: <a href="https://8888666.top/xingblog.github.io/css/main.css">https://8888666.top/xingblog.github.io/css/main.css</a></p><p>然后复制到浏览器 改成了: <a href="https://8888666.top/css/main.css">https://8888666.top/css/main.css</a></p><p>哎，您猜怎么着， 访问到了！ 可以，瞬间我明白了！🤪🤪🤪， 这不能带我的子仓库地址啊！</p><h2 id="修改hexo-的配置"><a href="#修改hexo-的配置" class="headerlink" title="修改hexo 的配置"></a>修改hexo 的配置</h2><p>马上找我的配置文件发现了问题，之前在 _config.yml 中 我配置的是我的路径：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://dreamshao.github.io/xingblog.github.io/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></code></pre></td></tr></table></figure><p>然后修改为：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://dreamshao.github.io/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></code></pre></td></tr></table></figure><p>然后清空已经生成的信息，也就是在public 文件夹下，清空完毕后执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo clean<br>hexo g -d<br></code></pre></td></tr></table></figure><p>结果在域名上访问就发现可以了，原来就是这点问题导致了，还是自己的配置问题！</p><h2 id="得到了什么？"><a href="#得到了什么？" class="headerlink" title="得到了什么？"></a>得到了什么？</h2><p>通过这次自己把博客通过自定义域名访问，确实收获了很多部署方面的知识， 比如什么是 CNAME，什么是 A 模式 等等。</p><p>还有更加了解DNS解析的模式，之前只是简单的了解，通过这次操作确实更加明白了！</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果你在部署博客到私人域名下有什么问题，可以留言哦，一定知无不言，言无不尽！</p>]]></content>
    
    
    <categories>
      
      <category>gitpages 自定义域名</category>
      
      <category>部分请求404</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>hexo 博客</tag>
      
      <tag>自定义域名访问gitpages</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下实现IOS自动化测试</title>
    <link href="/2024/06/28/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/06/28/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows-下实现IOS自动化测试"><a href="#Windows-下实现IOS自动化测试" class="headerlink" title="Windows 下实现IOS自动化测试"></a>Windows 下实现IOS自动化测试</h1><p>最近公司要实现Ios的自动化测试，但是局限是测试这边并没给配备MAC电脑，公司或者个人有MAC的东西可以潇洒的划走了😂😂😂</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="WebDriverAgent-介绍及安装"><a href="#WebDriverAgent-介绍及安装" class="headerlink" title="WebDriverAgent 介绍及安装"></a>WebDriverAgent 介绍及安装</h3><p>WebDriverAgent 是 facebook 推出的一款 ios 自动化测试的通信工具，目前facebook 的项目已经停止维护，现在使用的是 appium 官方维护的版本，下载地址：<a href="https://github.com/appium/WebDriverAgent%E3%80%82">https://github.com/appium/WebDriverAgent。</a></p><p>但是由于 WebDriverAgent 安装需要使用到 Mac 电脑，此处也是唯一需要 mac电脑的，使用 xcode 进行编译安装到手机端，具体操作可以自行百度！</p><p>目前我找 ios 开发同学帮我编译安装。</p><h3 id="Tidevice-介绍及安装"><a href="#Tidevice-介绍及安装" class="headerlink" title="Tidevice 介绍及安装"></a>Tidevice 介绍及安装</h3><p>一直以来，iOS 自动化的实现&amp;执行都依赖 Mac 系统，其主要原因是因为需要通过 Xcodebuild 编译&amp;安装 WDA (WebDriverAgent) 到 iOS 设备中，</p><p>通过 WDA 实现对被测应用进行操作。而 Windows 系统无法运行 Xcode 工具，所以无法运行 iOS 自动化测试。</p><p>针对这种情况，阿里团队开源了一个内部使用的iOS自动化工具 tidevice（<a href="https://github.com/alibaba/taobao-iphone-device%EF%BC%89">https://github.com/alibaba/taobao-iphone-device）</a></p><p>让我们可以更方便、简单的脱离 Mac 的限制，该工具能够用于与 iOS 设备进行通信, 提供以下功能 </p><ol><li><p>截图</p></li><li><p>   获取手机信息</p></li><li><p>   ipa 包的安装和卸载</p></li><li><p>   根据 bundleID 启动和停止应用 </p></li><li><p>列出安装应用信息</p></li><li><p>   模拟 Xcode 运行XCTest，常用的如启动 WebDriverAgent 测试(此方法不依赖xcodebuild)</p></li><li><p>   获取指定应用性能(CPU,MEM,FPS)</p></li><li><p>   支持运行在Mac，Linux，Windows 上 Tidevice 安装</p></li></ol><h4 id="版本要求"><a href="#版本要求" class="headerlink" title="版本要求"></a>版本要求</h4><p>Python 3.6+命令 pip install tidevice</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>查看版本号 tidevice version列出设备 tidevice list</p><p>查看安装包 tidevice applist更多功能请自己查询官方文档</p><h2 id="Tidevice操作步骤"><a href="#Tidevice操作步骤" class="headerlink" title="Tidevice操作步骤"></a>Tidevice操作步骤</h2><p>cmd 执行tidevice list 查看版本号,可以看到下面的信息</p><img src="/2024/06/28/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/cmd.png" class=""><p>Udid：手机唯一 id后面需要用到</p><p>然后执行 tidevice applist 查看我们的 webdriveragent 具体信息</p><img src="/2024/06/28/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/id.png" class=""><p>这个签名是自己写的，需要找对应安装同学确认一下！</p><p>再然后我们执行： tidevice -u 你的设备 id -B 你的webdriveraget –port 8100看到启动成功的字眼就可以了！</p><p>然后浏览器访问 127.0.0.1:8100&#x2F;status 查看到如下信息即可</p><img src="/2024/06/28/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/infor.png" class=""><p>表示当前服务正常，此时不可关闭当前 cmd 弹窗，需要一直保持！</p><h2 id="Appium-使用"><a href="#Appium-使用" class="headerlink" title="Appium 使用"></a>Appium 使用</h2><p>打开 appium 版本选择 1.20 以上的，我这里只是描述</p><p>然后点击start server V1.15.1</p><img src="/2024/06/28/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/appium.png" class=""><p>然后点击 如上图圈住的</p><img src="/2024/06/28/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/appium1.png" class=""><p>在 JSON Representation 输入</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;deviceName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;iPhone XS Max&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;platformName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ios&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;udid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;00008020-001604901A01002E&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;bundleId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;你的包名&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;platformVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;14.6&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;webDriverAgentUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:8100&quot;</span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;noReset&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;usePrebuiltWDA&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;useXctestrunFile&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;skipLogCapture&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <br><span class="hljs-attr">&quot;appium:automationName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;XCUITest&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面需要替换的信息包含 deviceName udid platformVersion bundleId 对应的写自己的信息即可！</p><p>然后点击 start session 就可以查看元素了</p><h2 id="代码操作"><a href="#代码操作" class="headerlink" title="代码操作"></a>代码操作</h2><p>这里的代码定位啊什么的和android一样，这里就不写这些基本命令了。</p>]]></content>
    
    
    <categories>
      
      <category>自动化测试</category>
      
      <category>Ios</category>
      
      <category>Windows 下实现IOS自动化测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Appium</tag>
      
      <tag>windows 下实现ios自动化测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常见函数之yield函数</title>
    <link href="/2024/06/28/yield%E5%87%BD%E6%95%B0/"/>
    <url>/2024/06/28/yield%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python常见函数之yield函数"><a href="#Python常见函数之yield函数" class="headerlink" title="Python常见函数之yield函数"></a>Python常见函数之yield函数</h1><p><code>yield</code> 在 Python 中是一个用于定义生成器的关键字，它允许函数在迭代过程中产生值，而不需要一次性计算所有值。以下是关于 <code>yield</code> 的更详细介绍：</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li><p><strong>定义生成器函数</strong>：当一个函数中包含了 <code>yield</code> 语句时，这个函数就被称为生成器函数。调用生成器函数时，它不会立即执行函数体中的全部代码，而是返回一个生成器对象。</p></li><li><p><strong>生成器的工作原理</strong>：生成器是一种特殊类型的迭代器，由生成器函数创建。当生成器函数执行到 <code>yield</code> 语句时，它会生成一个值，并保存其当前状态，然后等待下一次调用来继续执行。</p></li></ol><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol><li><p><strong>暂停和恢复</strong>：<code>yield</code> 允许函数在迭代过程中暂停和恢复，从而逐个生成值，而不是一次性计算所有值。</p></li><li><p><strong>内存效率</strong>：使用 <code>yield</code> 可以避免创建大型的列表来保存数据，从而节约内存。特别是当处理大量数据时，这种优势尤为明显。</p></li><li><p><strong>状态保持</strong>：生成器能够记住上一次返回时的状态，包括局部变量和堆栈信息等。这使得生成器能够在下次迭代时从上次离开的位置继续执行。</p></li></ol><h3 id="yield-的应用场景"><a href="#yield-的应用场景" class="headerlink" title="yield 的应用场景"></a>yield 的应用场景</h3><ol><li><p><strong>节省内存</strong>：生成器在生成值时会“暂停”函数，而不是像列表推导式那样一次性生成所有值。这对于处理大量数据或无限序列时非常有用，因为它允许你按需生成值，从而节省内存。</p></li><li><p><strong>简化代码</strong>：生成器可以用于简化复杂的迭代逻辑。例如，你可以使用生成器来模拟一个无限序列（如斐波那契数列），而无需在内存中存储整个序列。</p></li><li><p><strong>协同程序</strong>：虽然这不是 Python 的标准用法，但 <code>yield</code> 也可以用于实现协同程序（coroutines），这是一种可以暂停和恢复执行的函数。在 Python 3.5 及更高版本中，<code>async</code> 和 <code>await</code> 关键字被引入以更直接地支持异步编程，但 <code>yield</code> 仍然在某些场景中用于此目的。</p></li><li><p><strong>数据流水线</strong>：在数据分析和机器学习等领域中，生成器常用于创建数据流水线。你可以使用生成器函数从数据源中读取数据，对数据进行预处理，然后将处理后的数据传递给下一个阶段。由于生成器按需生成数据，因此这种流水线可以非常高效地处理大量数据。</p></li><li><p><strong>惰性求值</strong>：生成器允许你实现惰性求值（lazy evaluation），即只有在需要时才计算值。这在处理复杂计算或大型数据集时非常有用，因为它可以避免不必要的计算并节省资源。</p></li><li><p><strong>与迭代器的交互</strong>：生成器也是迭代器的一种，因此它们可以与任何接受迭代器的 Python 结构（如 <code>for</code> 循环、列表推导式、<code>map()</code>、<code>filter()</code> 等）一起使用。这使得生成器在 Python 中非常灵活和强大。</p></li></ol><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">simple_generator</span>():<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 创建生成器对象</span><br>generator = simple_generator()<br><br><span class="hljs-comment"># 通过 for 循环迭代生成器</span><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> generator:<br>    <span class="hljs-built_in">print</span>(value)  <span class="hljs-comment"># 输出: 1, 2, 3</span><br><br><span class="hljs-comment"># 也可以使用 next() 函数迭代生成器</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(generator))  <span class="hljs-comment"># 输出: StopIteration（因为生成器已经迭代完毕）</span><br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>当生成器函数执行到 <code>yield</code> 语句时，它会生成一个值并暂停执行。此时，生成器的状态会被保存下来，包括局部变量和堆栈信息等。</p></li><li><p>调用生成器对象的 <code>__next__()</code> 方法（或者在 for 循环中迭代）会使生成器恢复执行，直到遇到下一个 <code>yield</code> 语句或函数结束。</p></li><li><p>如果生成器函数中没有更多的 <code>yield</code> 语句或已经执行完毕，再次调用 <code>__next__()</code> 方法会引发 <code>StopIteration</code> 异常。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python 常见函数</category>
      
      <category>Python yield函数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
      <tag>yield</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常见函数之生成式</title>
    <link href="/2024/06/28/python%E7%94%9F%E6%88%90%E5%BC%8F/"/>
    <url>/2024/06/28/python%E7%94%9F%E6%88%90%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Python常见函数之生成式"><a href="#Python常见函数之生成式" class="headerlink" title="Python常见函数之生成式"></a>Python常见函数之生成式</h1><p>在Python中，生成式（Generator Expressions）是一种简洁的创建迭代器的方式，它们类似于列表推导式（List Comprehensions），但是生成式返回的是一个迭代器，而不是一个列表。这意味着生成式只会在迭代时生成值，而不是一次性生成所有值，从而节省了内存。</p><p>生成式的基本语法是使用圆括号 <code>()</code> 而不是方括号 <code>[]</code> 或花括号 <code>&#123;&#125;</code>（对于集合或字典推导式）。</p><p>下面是一些生成式的示例：</p><ol><li>创建一个生成偶数（从0到18）的生成式：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">even_numbers = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">19</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> even_numbers:<br>    <span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure><ol start="2"><li>创建一个从字符串中提取大写字母的生成式：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&quot;Hello, World!&quot;</span><br>uppercase_letters = (char <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> text <span class="hljs-keyword">if</span> char.isupper())<br><span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> uppercase_letters:<br>    <span class="hljs-built_in">print</span>(letter)<br></code></pre></td></tr></table></figure><ol start="3"><li>创建一个生成斐波那契数列的生成式（注意：这只是一个简单的示例，因为生成式本身并不适合生成无限序列，但我们可以限制其长度）：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>):<br>    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>        <span class="hljs-keyword">yield</span> a<br>        a, b = b, a + b<br><br>fib_sequence = fibonacci(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 创建一个生成前10个斐波那契数的生成器</span><br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> fib_sequence:<br>    <span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure><p>在这个斐波那契数列的例子中，我们实际上使用了一个生成器函数（通过<code>yield</code>关键字定义），但你也可以将其视为一个更复杂的生成式。在大多数情况下，如果你需要生成一个复杂的、可能是无限的序列，那么使用生成器函数会更为合适。</p><p>总的来说，生成式是Python中一种非常强大且内存高效的工具，用于在迭代时动态生成值。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python 常见函数</category>
      
      <category>Python 生成式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>窗外</title>
    <link href="/2024/06/27/%E7%AA%97%E5%A4%96/"/>
    <url>/2024/06/27/%E7%AA%97%E5%A4%96/</url>
    
    <content type="html"><![CDATA[<h1 id="窗外"><a href="#窗外" class="headerlink" title="窗外"></a>窗外</h1><p>因为我的工位挨着窗口</p><p>累了就会转头看一下窗外的景色</p><p>有形形色色的行人走来走去</p><p>心里想大家都一样吧</p><p>嗯！大家都一样！</p><p>转过头</p><p>不还得过这操蛋的日子！</p><img src="/2024/06/27/%E7%AA%97%E5%A4%96/%E6%93%8D%E8%9B%8B.jpeg" class="">]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>2024年随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>随笔</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常见函数之reduce函数用法</title>
    <link href="/2024/06/27/reduce%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <url>/2024/06/27/reduce%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Python常见函数之reduce函数用法"><a href="#Python常见函数之reduce函数用法" class="headerlink" title="Python常见函数之reduce函数用法"></a>Python常见函数之reduce函数用法</h1><p>可能突然提到reduce函数你觉得不认识，但是给你这么一个场景，假如我要你实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">str_to_number</span>(<span class="hljs-params">order</span>):<br>    digits = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;6&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;9&#x27;</span>: <span class="hljs-number">9</span>&#125;<br>    <span class="hljs-keyword">return</span> digits[order]<br></code></pre></td></tr></table></figure><p>我想让你利用上面的函数给我返回一个 12345</p><p>有人说可以啊 弄个列表每次传递一个对应的key获取value 然后append到列表里面。确实可以但是有点过于麻烦了，那么今天介绍的这个reduce函数绝效率嘎嘎的！</p><h2 id="reduce函数"><a href="#reduce函数" class="headerlink" title="reduce函数"></a>reduce函数</h2><p>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br></code></pre></td></tr></table></figure><p>这么看可能不明白，下面让我来举个例子！</p><p>对一个序列求和，就可以用reduce实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-built_in">print</span>(reduce(add, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])) <span class="hljs-comment"># 15</span><br></code></pre></td></tr></table></figure><p>这就实现了将 1,2,3,4,5 利用add 函数求和</p><p>亦或者 我们可以实现 将输入的内容按照整数输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a * <span class="hljs-number">10</span> + b<br><br><span class="hljs-built_in">print</span>(reduce(fn, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]))  <span class="hljs-comment"># 12345</span><br></code></pre></td></tr></table></figure><p>这下应能看明白里面的奥妙了吧！</p><p>应用到最开始的那个问题那么我们就可以这么来做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">str_to_number</span>(<span class="hljs-params">order</span>):<br>    digits = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;6&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;9&#x27;</span>: <span class="hljs-number">9</span>&#125;<br>    <span class="hljs-keyword">return</span> digits[order]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">str_to_number_reduce</span>(<span class="hljs-params">order</span>):<br>    <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x * <span class="hljs-number">10</span> + y, <span class="hljs-built_in">map</span>(str_to_number, order))<br><br><span class="hljs-built_in">print</span>(str_to_number_reduce([<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>])) <span class="hljs-comment"># 12345</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python 常见函数</category>
      
      <category>Python reduce函数用法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常见函数之函数固定形参</title>
    <link href="/2024/06/27/python%E5%87%BD%E6%95%B0%E5%9B%BA%E5%AE%9A%E5%BD%A2%E5%8F%82/"/>
    <url>/2024/06/27/python%E5%87%BD%E6%95%B0%E5%9B%BA%E5%AE%9A%E5%BD%A2%E5%8F%82/</url>
    
    <content type="html"><![CDATA[<h1 id="Python常见函数之固定形参"><a href="#Python常见函数之固定形参" class="headerlink" title="Python常见函数之固定形参"></a>Python常见函数之固定形参</h1><p>如果有这样一个函数 add(a, b), 此时你进行调用的时候肯定知道需要传递两个形参 比如 add(1,2)， 但是如果我只想实现1的加法怎么办，有人说可以啊 每次都传递add(1,x) 就行但是这样可能还是会让别人误解！</p><p>那么， 如果我这样只需要传递add(2)或add(5) 就可以实现刚刚的算法，那么这样就算是将我们其中一个参数固定了，那么一起来看看怎么实现吧！</p><h2 id="functools-partial"><a href="#functools-partial" class="headerlink" title="functools.partial"></a>functools.partial</h2><p>partial用于部分应用一个函数，它基于一个函数创建一个可调用对象，把原函数的某些参数固定，调用时只需要传递未固定的参数即可。</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(a + b)<br><br><br>add = functools.partial(add, <span class="hljs-number">1</span>)<br>add(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 输出：3</span><br></code></pre></td></tr></table></figure><p>add函数原本接收两个参数a和b，经过partial包装之后，a参数的值被固定为了1，新的add对象（注意此处add已经是一个可调用对象，而非函数，下文分析源码会看到）只需要接收一个参数即可。</p><p>通俗点说：就是把原函数的部分参数固定了初始值，新的调用只需要传递其它参数。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python 常见函数</category>
      
      <category>Python 函数固定形参</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LocustFile编写</title>
    <link href="/2024/06/27/locustfile%E7%BC%96%E5%86%99/"/>
    <url>/2024/06/27/locustfile%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="LocustFile编写"><a href="#LocustFile编写" class="headerlink" title="LocustFile编写"></a>LocustFile编写</h1><p>编写LocustFile 可以使得我们的性能测试功能更加强大实现我们自定义的测试路径及判断错误等方法！</p><h2 id="LocustFile-Demo"><a href="#LocustFile-Demo" class="headerlink" title="LocustFile Demo"></a>LocustFile Demo</h2><p>来自 LousctFile 官网例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> locust <span class="hljs-keyword">import</span> HttpUser, task, between<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickstartUser</span>(<span class="hljs-title class_ inherited__">HttpUser</span>):<br>    wait_time = between(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-meta">    @task</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>(<span class="hljs-params">self</span>):<br>        self.client.get(<span class="hljs-string">&quot;/hello&quot;</span>)<br>        self.client.get(<span class="hljs-string">&quot;/world&quot;</span>)<br><br><span class="hljs-meta">    @task(<span class="hljs-params"><span class="hljs-number">3</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">view_items</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> item_id <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>            self.client.get(<span class="hljs-string">f&quot;/item?id=<span class="hljs-subst">&#123;item_id&#125;</span>&quot;</span>, name=<span class="hljs-string">&quot;/item&quot;</span>)<br>            time.sleep(<span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_start</span>(<span class="hljs-params">self</span>):<br>        self.client.post(<span class="hljs-string">&quot;/login&quot;</span>, json=&#123;<span class="hljs-string">&quot;username&quot;</span>:<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>:<span class="hljs-string">&quot;bar&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p>这里我想还是采用官网的例子介绍，为了防止我讲的不够清晰 大家也可以访问下面的链接去官网查看</p><p><a href="https://docs.locust.io/en/stable/writing-a-locustfile.html">https://docs.locust.io/en/stable/writing-a-locustfile.html</a></p><h2 id="解释（我的理解）"><a href="#解释（我的理解）" class="headerlink" title="解释（我的理解）"></a>解释（我的理解）</h2><p>其实从中可以看到这个案例和我们平常写的类好像没什么区别，除了继承了<font color=green >HttpUser</font>,以及用例<font color=green >@task</font> 装饰器</p><p>那么首先来看一下具体实现了什么功能呢？</p><h3 id="on-start"><a href="#on-start" class="headerlink" title="on_start()"></a>on_start()</h3><p>这个类实现了一个性能测试脚本，在每个模拟用户启动时，都会调用此名称的方法 会先运行 <font color=green >on_start</font>这个函数,然后进行了请求这里的host 可以在shell中指定也可以在web ui的那个界面中输入，可以看到进行了一个post请求，路径是 &#x2F;login, 请求体是一个json对象</p><p>然后会在继续执行 这里的<font color=green >@task</font> 着重讲一下</p><h3 id="task-装饰器"><a href="#task-装饰器" class="headerlink" title="task 装饰器"></a>task 装饰器</h3><p>@task 装饰器 表明当前方法是一个任务</p><p>@task 是locust文件的核心。对于每个正在运行的用户，Locust 都会创建一个greenlet（协程或“微线程”），然后进行请求，要注意此时不是并发请求，是在&#x2F;hello 响应返回后才会继续请求&#x2F;world</p><p>@task(3) 其中3是指权重，虽然程序运行是随机选择任务单是你给予了更大的权重的话运行的次数会更加多</p><h3 id="wait-time"><a href="#wait-time" class="headerlink" title="wait_time"></a>wait_time</h3><p>wait_time 方法在每次任务执行后引入延迟。如果没有指定wait_time，则下一个任务将在上一个任务完成后立即执行。</p><p>有四个函数 分别是：constant、 bettwen、 constant_throughput、constant_pacing</p><p>constant: 在固定的时间内</p><p>让每个用户每次执行固定的时间 1秒：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">wait_time = constant(<span class="hljs-number">0.5</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>bettwen: 在最小值和最大值之间的随机时间</p><p>让每个用户在每次执行任务之间等待 1 到 4 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">wait_time = between(<span class="hljs-number">0.5</span>, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>constant_throughput：返回一个跟踪任务运行时间的函数，每次调用时，它将返回一个等待时间，该等待时间将尝试使每秒执行的任务运行次数等于 task_runs_per_second 参数指定的时间</p><p>也就是说：以恒定的速率执行任务。它允许用户设置每秒或每分钟需要执行的任务数，以确保性能测试的稳定性。</p><p>应用场景：</p><pre><code class="hljs">在性能测试中，可能需要模拟不同的用户行为，如登录、搜索、购买等。constant_throughput 可以确保这些任务以恒定的速率执行，从而更准确地评估系统的性能和稳定性。在生产环境中，有时需要根据客户的需求设置应用的吞吐量。constant_throughput 可以帮助确保应用能够满足用户的需求，同时保持系统的稳定性。</code></pre><p>也是 constant_pacing 的倒数</p><p>无论任务执行时间如何，任务将始终每 10 秒执行一次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">wait_time = constant_throughput(<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><p>constant_pacing：返回一个跟踪任务运行时间的函数，每次调用时它将返回一个等待时间，该等待时间将尝试使任务执行之间的总时间等于 wait_time 参数指定的时间。</p><p>应用场景：</p><p>   模拟真实用户行为：</p><pre><code class="hljs">当进行性能测试时，有时需要模拟真实用户的操作行为。这些用户行为可能不是均匀分布的，但某些特定行为（如定期查询、定时任务等）需要按照固定的时间间隔来执行。使用 constant_pacing 可以确保这些任务按照预定的时间间隔执行，从而更准确地模拟真实用户的行为。</code></pre><p>  系统稳定性测试：</p><pre><code class="hljs">在测试系统的稳定性时，可能需要长时间运行任务，并观察系统在不同负载下的表现。使用 constant_pacing 可以确保任务以恒定的间隔执行，从而持续向系统施加稳定的负载，帮助发现潜在的稳定性和性能问题。</code></pre><p>  资源分配和限制：</p><pre><code class="hljs">在某些场景下，可能需要限制系统资源的使用，以确保不会超出特定的限制。例如，在测试一个API接口时，可能需要限制每分钟的请求数以避免对后端服务造成过大的压力。虽然 constant_throughput 可以用来控制每秒的请求数，但 constant_pacing 可以提供更细粒度的控制，确保请求按照特定的时间间隔发送，从而更有效地管理资源使用。</code></pre><p>  定时任务的性能测试：</p><pre><code class="hljs">许多系统都包含定时任务，这些任务需要按照预定的时间间隔执行。在进行这些定时任务的性能测试时，可以使用 constant_pacing 来模拟定时任务的执行间隔，并评估系统在不同负载下的性能表现。</code></pre><p>  实时数据收集和处理：</p><p>   对于需要实时收集和处理数据的系统（如监控系统、日志分析系统等），可能需要按照固定的时间间隔来执行数据收集和处理任务。使用 </p><p>   constant_pacing 可以确保这些任务按照预定的时间间隔执行，从而确保数据的准确性和实时性。</p><p>总的来说，constant_pacing 适用于那些需要精确控制任务执行间隔的场景，无论是在性能测试、资源分配还是实时数据处理中都可以发挥其独特的作用。</p><p>可以理解为：就像一个定时器一样 他不关心你具体返回了没有 到了点就要执行</p><p>无论任务执行时间如何，任务将始终每 10 秒执行一次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">wait_time = constant_pacing(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h3 id="HttpUser"><a href="#HttpUser" class="headerlink" title="HttpUser"></a>HttpUser</h3><p> HttpUser每个用户提供一个client属性，即 的一个实例HttpSession，可用于向我们想要加载测试的目标系统发出 HTTP 请求。</p><p> HttpUser里面也是封装了一系列的请求方式，例如 POST, GET , DELETE, PUT 等。</p>]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Locust</category>
      
      <category>Locust File编写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Locust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Locust 入门安装及界面介绍</title>
    <link href="/2024/06/27/locust%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/06/27/locust%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Locust-入门安装及界面介绍"><a href="#Locust-入门安装及界面介绍" class="headerlink" title="Locust 入门安装及界面介绍"></a>Locust 入门安装及界面介绍</h1><h2 id="什么是-Locust？"><a href="#什么是-Locust？" class="headerlink" title="什么是 Locust？"></a>什么是 Locust？</h2><p>Locust 是一款针对 HTTP 和其他协议的开源性能&#x2F;负载测试工具， 相比于Jmeter 或者 LoadRunner 来说相对更加轻便，在单机下的性能更加强悍！</p><p>Locust 测试可通过命令行或基于 Web 的 UI 运行。可以实时查看吞吐量、响应时间和错误，并&#x2F;或导出以供日后分析。</p><p>也可以将常规 Python 库导入到测试中，借助 Locust 的可插入式架构，它可以无限扩展。与使用大多数其他工具不同，您的测试设计永远不会受到 GUI 或特定领域语言的限制。</p><p>他之所以性能强悍是因为Locust 可轻松在多台机器上分布运行负载测试。它基于事件（使用gevent），这使得单个进程可以处理数千个并发用户。虽然可能还有其他工具能够在给定硬件上每秒处理更多请求，但 Locust 每个用户的低开销使其非常适合测试高度并发的工作负载。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install locust<br></code></pre></td></tr></table></figure><h2 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">locust -V<br>locust <span class="hljs-number">2.29</span><span class="hljs-number">.1</span> <span class="hljs-keyword">from</span> /usr/local/lib/python3<span class="hljs-number">.10</span>/site-packages/locust (python <span class="hljs-number">3.10</span><span class="hljs-number">.6</span>)<br></code></pre></td></tr></table></figure><h2 id="locust-的启动"><a href="#locust-的启动" class="headerlink" title="locust 的启动"></a>locust 的启动</h2><p>可以在命令行中执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">locust<br></code></pre></td></tr></table></figure><p>运行成功可以看到</p><p>打开 <a href="http://localhost:8089/">http://localhost:8089/</a></p><p>可以看到</p><img src="/2024/06/27/locust%E5%AD%A6%E4%B9%A0/locust%E7%95%8C%E9%9D%A2.png" class=""><p>此时就已经启动成功了！</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>界面中的 Number of users：用户数量也就是你并发的用户量</p><p>界面中的 Spawn rate：用户量的生成速率按秒</p><p>界面中的 Host：主机地址 也就是域名地址</p>]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Locust</category>
      
      <category>Locust 介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Locust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题目之SQL面试题目之可以举一反三的SQL问题</title>
    <link href="/2024/06/27/SQL%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <url>/2024/06/27/SQL%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题目之SQL面试题目可以举一反三的SQL问题"><a href="#面试题目之SQL面试题目可以举一反三的SQL问题" class="headerlink" title="面试题目之SQL面试题目可以举一反三的SQL问题"></a>面试题目之SQL面试题目可以举一反三的SQL问题</h1><h1 id="经典的sql题目可以举一反三"><a href="#经典的sql题目可以举一反三" class="headerlink" title="经典的sql题目可以举一反三"></a>经典的sql题目可以举一反三</h1><p>表结构：</p><ul><li>学生表student(id,name)</li><li>课程表course(id,name)</li><li>学生成绩表student_course(sid,cid,score)</li></ul><h2 id="编写创建表的sql"><a href="#编写创建表的sql" class="headerlink" title="编写创建表的sql"></a>编写创建表的sql</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student( id <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">primary</span> key auto_increment, <br>name <span class="hljs-type">char</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> ); <br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;张三&#x27;</span>),(<span class="hljs-string">&#x27;李四&#x27;</span>); <br> <br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> course( id <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">primary</span> key auto_increment, name <span class="hljs-type">char</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> ); <br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> course(name) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;语文&#x27;</span>),(<span class="hljs-string">&#x27;数学&#x27;</span>);  <br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student_course( sid <span class="hljs-type">int</span> unsigned, cid <span class="hljs-type">int</span> unsigned, score <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>, <br><span class="hljs-keyword">foreign</span> key (sid) <span class="hljs-keyword">references</span> student(id), <span class="hljs-keyword">foreign</span> key (cid) <span class="hljs-keyword">references</span> course(id), <span class="hljs-keyword">primary</span> key(sid, cid) ); <br><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student_course <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">80</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">90</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">90</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">70</span>);<br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="查询student表中重名的学生，结果包含id和name，按name-id升序"><a href="#查询student表中重名的学生，结果包含id和name，按name-id升序" class="headerlink" title="查询student表中重名的学生，结果包含id和name，按name,id升序"></a>查询student表中重名的学生，结果包含id和name，按name,id升序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,name<br><span class="hljs-keyword">from</span> student<br><span class="hljs-keyword">where</span> name <span class="hljs-keyword">in</span> (<br><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> student <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> name <span class="hljs-keyword">having</span>(<span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>)<br>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><p>我们经常需要查询某一列重复的行，一般通过group by(有重复的列)然后取count&gt;1的值。 关系型数据库有他的局限性， 有些看似简单的查询写出来的sql很复杂，而且效率也会很低。</p><h3 id="在student-course表中查询平均分不及格的学生，列出学生id和平均分"><a href="#在student-course表中查询平均分不及格的学生，列出学生id和平均分" class="headerlink" title="在student_course表中查询平均分不及格的学生，列出学生id和平均分"></a>在student_course表中查询平均分不及格的学生，列出学生id和平均分</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sid,<span class="hljs-built_in">avg</span>(score) <span class="hljs-keyword">as</span> avg_score<br><span class="hljs-keyword">from</span> student_course<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sid <span class="hljs-keyword">having</span>(avg_score<span class="hljs-operator">&lt;</span><span class="hljs-number">60</span>);<br></code></pre></td></tr></table></figure><p>group by和having是最常考的 where子句中不能用聚集函数作为条件表达式，但是having短语可以，where和having的区别在于对用对象不同，where作用于记录，having作用于组。</p><h3 id="在student-course表中查询每门课成绩都不低于80的学生id"><a href="#在student-course表中查询每门课成绩都不低于80的学生id" class="headerlink" title="在student_course表中查询每门课成绩都不低于80的学生id"></a>在student_course表中查询每门课成绩都不低于80的学生id</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> sid<br><span class="hljs-keyword">from</span> student_course<br><span class="hljs-keyword">where</span> sid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<br><span class="hljs-keyword">select</span> sid <span class="hljs-keyword">from</span> student_course<br><span class="hljs-keyword">where</span> score <span class="hljs-operator">&lt;</span> <span class="hljs-number">80</span>);<br></code></pre></td></tr></table></figure><p>用到反向思想，其实就是数理逻辑中的∀x:P和¬∃x:¬P是等价的。</p><h3 id="查询每个学生的总成绩，结果列出学生姓名和总成绩-如果使用下面的sql会过滤掉没有成绩的人"><a href="#查询每个学生的总成绩，结果列出学生姓名和总成绩-如果使用下面的sql会过滤掉没有成绩的人" class="headerlink" title="查询每个学生的总成绩，结果列出学生姓名和总成绩 如果使用下面的sql会过滤掉没有成绩的人"></a>查询每个学生的总成绩，结果列出学生姓名和总成绩 如果使用下面的sql会过滤掉没有成绩的人</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name,<span class="hljs-built_in">sum</span>(score) total<br><span class="hljs-keyword">from</span> student,student_course<br><span class="hljs-keyword">where</span> student.id<span class="hljs-operator">=</span>student_course.sid<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sid;<br></code></pre></td></tr></table></figure><p>更保险的做法应该是使用 左外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name,<span class="hljs-built_in">sum</span>(score)<br><span class="hljs-keyword">from</span> student <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> student_course<br><span class="hljs-keyword">on</span> student.id<span class="hljs-operator">=</span>student_course.sid<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sid;<br></code></pre></td></tr></table></figure><h3 id="总成绩最高的学生，结果列出学生id和总成绩-下面的sql效率很低，因为要重复计算所有的总成绩。"><a href="#总成绩最高的学生，结果列出学生id和总成绩-下面的sql效率很低，因为要重复计算所有的总成绩。" class="headerlink" title="总成绩最高的学生，结果列出学生id和总成绩 下面的sql效率很低，因为要重复计算所有的总成绩。"></a>总成绩最高的学生，结果列出学生id和总成绩 下面的sql效率很低，因为要重复计算所有的总成绩。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sid,<span class="hljs-built_in">sum</span>(score) <span class="hljs-keyword">as</span> sum_score<br><span class="hljs-keyword">from</span> student_course <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sid <span class="hljs-keyword">having</span> sum_score<span class="hljs-operator">&gt;=</span><span class="hljs-keyword">all</span><br>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(score) <span class="hljs-keyword">from</span> student_course <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sid);<br></code></pre></td></tr></table></figure><p>因为order by中可以使用聚集函数，最简单的方法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sid,<span class="hljs-built_in">sum</span>(score) <span class="hljs-keyword">as</span> sum_score<br><span class="hljs-keyword">from</span> student_course <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sid<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sum_score <span class="hljs-keyword">desc</span> limit <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>同理可以查总成绩的前三名。</p>]]></content>
    
    
    <categories>
      
      <category>面试题目搜集</category>
      
      <category>SQL面试题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>算法</tag>
      
      <tag>Appium</tag>
      
      <tag>Selenium</tag>
      
      <tag>pytest</tag>
      
      <tag>SQL</tag>
      
      <tag>Redis</tag>
      
      <tag>Nginx</tag>
      
      <tag>用例设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题目搜集之Python 算法题目动态规划问题</title>
    <link href="/2024/06/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%90%9C%E9%9B%86/"/>
    <url>/2024/06/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%90%9C%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题目搜集之Python-算法题目动态规划问题"><a href="#面试题目搜集之Python-算法题目动态规划问题" class="headerlink" title="面试题目搜集之Python 算法题目动态规划问题"></a>面试题目搜集之Python 算法题目动态规划问题</h1><h2 id="来自某大厂"><a href="#来自某大厂" class="headerlink" title="来自某大厂"></a>来自某大厂</h2><p>一个机器人人位于一个 m x n 网格的左上角（起始点在下图中标记为“Start”），机器人每次只能向下或者向右移动一步，机器人试图达到网格的右下角(在下图中标记为“Finish”),问总共有多少条不同的路径？</p><h2 id="逻辑分析"><a href="#逻辑分析" class="headerlink" title="逻辑分析"></a>逻辑分析</h2><p>这是一个经典的动态规划问题。我们可以定义一个二维数组dp，其中dp[i][j]表示从左上角到达(i, j)这个格子的不同路径数量。</p><p>由于机器人只能向右或向下移动，因此到达(i, j)的路径数量等于到达其上方格子(i-1, j)的路径数量加上到达其左方格子(i, j-1)的路径数量。</p><p>（i &#x3D; 0）和第一列（j &#x3D; 0）的格子，由于它们只能从一个方向（分别是左方和上方）到达，因此路径数量都是1。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m: <span class="hljs-built_in">int</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        result = [[<span class="hljs-number">1</span>] * m <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> index1 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):<br>            <span class="hljs-keyword">for</span> index2 <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,m):<br>                result[index1][index2] = result[index1 - <span class="hljs-number">1</span>][index2] + result[index1][index2 - <span class="hljs-number">1</span>]<br>        output = result[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">return</span> output<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    re = Solution()<br>    m=<span class="hljs-number">2</span><br>    n=<span class="hljs-number">3</span><br>    result=re.uniquePaths(m,n)<br>    <span class="hljs-built_in">print</span>(result)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题目搜集</category>
      
      <category>Python 算法题目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
      <tag>算法</tag>
      
      <tag>Appium</tag>
      
      <tag>Selenium</tag>
      
      <tag>pytest</tag>
      
      <tag>SQL</tag>
      
      <tag>Redis</tag>
      
      <tag>Nginx</tag>
      
      <tag>用例设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常见函数之RSA算法加密</title>
    <link href="/2024/06/27/RSA%E5%8A%A0%E5%AF%86/"/>
    <url>/2024/06/27/RSA%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Python常见函数之RSA加密"><a href="#Python常见函数之RSA加密" class="headerlink" title="Python常见函数之RSA加密"></a>Python常见函数之RSA加密</h1><p>来自维基百科：RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是由罗纳德·李维斯特、阿迪·萨莫尔和伦纳德·阿德曼在1977年一起提出的。当时他们三人都在麻省理工学院工作。RSA 就是他们三人姓氏开头字母拼在一起组成的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> PKCS1_v1_5 <span class="hljs-keyword">as</span> Cipher_pkcs1_v1_5<br><span class="hljs-keyword">from</span> Crypto.Signature <span class="hljs-keyword">import</span> PKCS1_v1_5<br><span class="hljs-keyword">from</span> Crypto.PublicKey <span class="hljs-keyword">import</span> RSA<br><span class="hljs-keyword">from</span> Crypto.Hash <span class="hljs-keyword">import</span> SHA<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> Crypto<br><span class="hljs-keyword">import</span> secrets<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rsa_long_encrypt</span>(<span class="hljs-params">pub_key_str, msg</span>):<br>    msg = msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    length = <span class="hljs-built_in">len</span>(msg)<br>    default_length = <span class="hljs-number">117</span><br>    <span class="hljs-comment">#公钥加密</span><br>    pubobj = Cipher_pkcs1_v1_5.new(RSA.importKey(pub_key_str))<br>    <span class="hljs-comment">#长度不用分段</span><br>    <span class="hljs-keyword">if</span> length &lt; default_length:<br>        <span class="hljs-keyword">return</span> base64.b64encode(pubobj.encrypt(msg))<br>    <span class="hljs-comment">#需要分段</span><br>    offset = <span class="hljs-number">0</span><br>    res = []<br>    <span class="hljs-keyword">while</span> length - offset &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">if</span> length - offset &gt; default_length:<br>            res.append(pubobj.encrypt(msg[offset:offset+default_length]))<br>        <span class="hljs-keyword">else</span>:<br>            res.append(pubobj.encrypt(msg[offset:]))<br>        offset += default_length<br>    byte_data = <span class="hljs-string">b&#x27;&#x27;</span>.join(res)<br>    <span class="hljs-built_in">print</span>(base64.b64encode(byte_data))<br>    <span class="hljs-keyword">return</span> base64.b64encode(byte_data)<br><br>publickey = <span class="hljs-string">&#x27;your publick key&#x27;</span><br>public_key = <span class="hljs-string">&#x27;-----BEGIN PUBLIC KEY-----\n&#x27;</span>+ publickey +<span class="hljs-string">&#x27;\n-----END PUBLIC KEY-----&#x27;</span><br><br>data = &#123;<br>    <span class="hljs-string">&quot;payAmount&quot;</span>: <span class="hljs-number">1000000</span>,<br>    <span class="hljs-string">&quot;payChId&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;bankAssetId&quot;</span>: <span class="hljs-number">1001</span><br>&#125;<br><br>first = secrets.token_bytes(<span class="hljs-number">16</span>)<br>result = base64.b64encode(first).decode()<br><span class="hljs-built_in">print</span>(result)<br><span class="hljs-comment">#password = &#x27;password=&#x27;+result</span><br>password=<span class="hljs-string">&#x27;password=WBAPfpP5ph2MrWSOkznJGA==&#x27;</span><br><span class="hljs-built_in">print</span>(password)<br>infor = json.dumps(data)<br><span class="hljs-built_in">print</span>(infor)<br>infor=rsa_long_encrypt(public_key,password)<br><span class="hljs-built_in">print</span>(infor)<br><span class="hljs-built_in">print</span>(infor.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python 常见函数</category>
      
      <category>Python RSA算法加密</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
      <tag>RSA算法加密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fiddler之过滤功能</title>
    <link href="/2024/06/27/fillder%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/"/>
    <url>/2024/06/27/fillder%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="Fillder过滤功能"><a href="#Fillder过滤功能" class="headerlink" title="Fillder过滤功能"></a>Fillder过滤功能</h1><p>Fillder 支持过滤HTTP请求，也可以通过标记不同的sessions 赋予不同的颜色进行区分。</p><h2 id="过滤sessions"><a href="#过滤sessions" class="headerlink" title="过滤sessions"></a>过滤sessions</h2><p>我们可以通过Find Sessions去发现我们想要的sessions会以黄色高亮显示，然后可以进行保存Fiddler中保存包，<br>选择你想保存的会话，然后单击File-&gt;Save-&gt;Selected Sessions，保存后的文件后缀是.saz。</p><p>文件中会保存完整的HTTP请求和HTTP响应，双击.saz文件，或者单击Fiddler菜单栏中的File-&gt;Load Archive,就能打开.saz文件。</p><h2 id="Fiddler中编辑会话"><a href="#Fiddler中编辑会话" class="headerlink" title="Fiddler中编辑会话"></a>Fiddler中编辑会话</h2><p>默认的情况下，Fiddler中的session是不可以修改的，选择一个session,用鼠标右键选择“Unlock For Editing”（快捷键是[F12]),这样就可以在Inspectors的Raw模式下编辑HTTP请求响应</p><h2 id="过滤会话"><a href="#过滤会话" class="headerlink" title="过滤会话"></a>过滤会话</h2><p>每次启动Fiddler，打开一个网页，都能看到十几个会话，看得人眼花缭乱，我们可以使用fiddler功能来过滤。<br>在Fiddler中找到Filters选项卡，选中”Use Filters”，就可以启动过滤功能。</p><img src="/2024/06/27/fillder%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/%E8%BF%87%E6%BB%A4.png" class=""><p>Filters的Actions中，我们可以保存当前的过滤设置，也可以加载已经保存好的过滤设置。</p><img src="/2024/06/27/fillder%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/%E4%BF%9D%E5%AD%98%E8%BF%87%E6%BB%A4.png" class=""><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><p>快速帮助我们选择session的快捷键</p><table><thead><tr><th>快捷键</th><th>用途</th></tr></thead><tbody><tr><td>CTRL+X</td><td>删除所有的Session</td></tr><tr><td>CTRL+A</td><td>选择所有的Session</td></tr><tr><td>ESC</td><td>不选择任何的Session</td></tr><tr><td>CTRL+I</td><td>反选Session</td></tr><tr><td>Delete</td><td>删除选择的Session</td></tr><tr><td>Shift+Delete</td><td>删除未选择的Session</td></tr><tr><td>R</td><td>重放选择的Session（可以重放多个Session）</td></tr><tr><td>SHIFT+R</td><td>多次重放选择的Session(随后会提示你输入，重放几次)</td></tr><tr><td>U</td><td>无条件地重放选择的Session（不会发送IF-Modified-Since和IF-None-Match Headers)</td></tr><tr><td>SHIFT+U</td><td>无条件的重放选择的Session（随后会提示你输入，重放几次)</td></tr><tr><td>P</td><td>选择“当前Seesion”的”父Session”（这个功能取决于Referer Header)</td></tr><tr><td>C</td><td>选择“当前Session”的”子Session”</td></tr><tr><td>D</td><td>选择“重复的Session”(有相同的URL和相同的method）</td></tr><tr><td>BackSpace或鼠标上的”Back”</td><td>选择“上次选择的Session”</td></tr><tr><td>Insert</td><td></td></tr><tr><td>CTRL+1CTRL+2CTRL+3CTRL+4CTRL+5CTRL+6</td><td>用粗体和颜色标记选择的Session</td></tr><tr><td>M</td><td>给选择的Session添加注释</td></tr></tbody></table><h2 id="QuickExec命令行的使用"><a href="#QuickExec命令行的使用" class="headerlink" title="QuickExec命令行的使用"></a>QuickExec命令行的使用</h2><p>Fiddler的左下角有一个命令行工具叫做QuickExec,允许你直接输入命令</p><img src="/2024/06/27/fillder%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/quickseck.png" class=""><p>常见命令如下：</p><p>help: 大力官方的使用页面的介绍，所有的命令都会列出来</p><p>Cls: 清屏（CTRL+X）快捷键也可以清屏)</p><p>Select:选择会话的命令</p><p>?.png:用来选择.png后缀的图片</p><p>Bpu:捕获request</p><p>Urlreplace:替换掉host</p>]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Fillder</category>
      
      <category>Fillder 过滤功能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Fillder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fillder的Decode/Encode小工具</title>
    <link href="/2024/06/27/fillder%E8%A7%A3%E7%A0%81%E5%B7%A5%E5%85%B7/"/>
    <url>/2024/06/27/fillder%E8%A7%A3%E7%A0%81%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="Fillder的Decode-Encode小工具"><a href="#Fillder的Decode-Encode小工具" class="headerlink" title="Fillder的Decode&#x2F;Encode小工具"></a>Fillder的Decode&#x2F;Encode小工具</h1><p>可以通过单击工具栏中的”TextWizard”，就可以启动TextWizard小工具，可以支持很多不同的算法</p><img src="/2024/06/27/fillder%E8%A7%A3%E7%A0%81%E5%B7%A5%E5%85%B7/%E8%A7%A3%E7%A0%81.png" class="">]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Fillder</category>
      
      <category>Fillder 的Decode/Encode小工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Fillder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fillder断点修改HTTP报文</title>
    <link href="/2024/06/27/fillder%E6%96%AD%E7%82%B9%E4%BF%AE%E6%94%B9HTTP%E6%8A%A5%E6%96%87/"/>
    <url>/2024/06/27/fillder%E6%96%AD%E7%82%B9%E4%BF%AE%E6%94%B9HTTP%E6%8A%A5%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Fillder-断点修改HTTP报文"><a href="#Fillder-断点修改HTTP报文" class="headerlink" title="Fillder 断点修改HTTP报文"></a>Fillder 断点修改HTTP报文</h1><p>Fiddler可以修改任何HTTP请求的信息。</p><h2 id="全局断点"><a href="#全局断点" class="headerlink" title="全局断点"></a>全局断点</h2><p>启动Fiddler，单击菜单栏种的Rules-&gt;Automatics Breakpoint-&gt;Before Requests，或者使用快捷键【F11】,这种方法会拦截所有的对话。</p><img src="/2024/06/27/fillder%E6%96%AD%E7%82%B9%E4%BF%AE%E6%94%B9HTTP%E6%8A%A5%E6%96%87/%E5%85%A8%E5%B1%80%E6%96%AD%E7%82%B9.png" class=""><p>想要取消全局断点，可以单击Rules-&gt;Automatic Breakpoint -&gt; Disabled，或者快捷键【shift+F11】。</p><h2 id="单个断点"><a href="#单个断点" class="headerlink" title="单个断点"></a>单个断点</h2><p>已知某个请求URL地址，这个时候只需要针对一个请求打断点调试，其他的请求不拦截。</p><p>在fiddler 左下角的QuickExec命令中输入命令” bpu  拦截的网址“就可以实现拦截效果,取修改拦截的信息。</p><img src="/2024/06/27/fillder%E6%96%AD%E7%82%B9%E4%BF%AE%E6%94%B9HTTP%E6%8A%A5%E6%96%87/%E5%8D%95%E4%B8%AA%E6%96%AD%E7%82%B9.png" class=""><h2 id="Fiddler修改HTTP请求"><a href="#Fiddler修改HTTP请求" class="headerlink" title="Fiddler修改HTTP请求"></a>Fiddler修改HTTP请求</h2><img src="/2024/06/27/fillder%E6%96%AD%E7%82%B9%E4%BF%AE%E6%94%B9HTTP%E6%8A%A5%E6%96%87/%E4%BF%AE%E6%94%B9HTTP%E6%8A%A5%E6%96%87.png" class=""><p>如果想继续拦截可以点击黄色按钮”Break on Response”这个按钮，会继续拦截这个HTTP请求的响应。</p><p>Fiddler中设置断点修改HTTP响应 用法同上述全局断点， 单个断点<br> <br>第一种是全局断点，启动fiddler，单击Rulers-&gt;Automatic Breakpoint-&gt;After Response这种方法会中断所有的会话。<br>想要取消断点 ，可以单击Rules-&gt;Automatic Breakpoint-&gt;Disabled。<br>第二种是单个断点，在命令行“bpafter <a href="http://www.baidu.com”/">www.baidu.com”</a> 这种方法只会中断<a href="http://www.baidu.com./">www.baidu.com。</a><br>想要消除单个断点，可以在命令行中输入命令”bpafter”。</p><h2 id="伪造Referer"><a href="#伪造Referer" class="headerlink" title="伪造Referer"></a>伪造Referer</h2><img src="/2024/06/27/fillder%E6%96%AD%E7%82%B9%E4%BF%AE%E6%94%B9HTTP%E6%8A%A5%E6%96%87/%E4%BF%AE%E6%94%B9refer.png" class=""><p>拦截后我们可以在Raw中写入Refere：ww.dddddr.cn就可以 </p>]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Fillder</category>
      
      <category>Fillder 断点修改HTTP报文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Fillder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fillder简单的性能测试</title>
    <link href="/2024/06/27/fillder%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/06/27/fillder%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Fillder-简单的性能测试"><a href="#Fillder-简单的性能测试" class="headerlink" title="Fillder 简单的性能测试"></a>Fillder 简单的性能测试</h1><h2 id="通过查看statistics面板查看"><a href="#通过查看statistics面板查看" class="headerlink" title="通过查看statistics面板查看"></a>通过查看statistics面板查看</h2><img src="/2024/06/27/fillder%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/fillder%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.png" class=""><p>我们打开一个网页的请求，通过查看Statistics面板可以清楚的看到每个HTTP请求的响应时间。</p>]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Fillder</category>
      
      <category>Fillder 简单的性能测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Fillder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常见函数之 python时间戳</title>
    <link href="/2024/06/27/python%E6%97%B6%E9%97%B4%E6%88%B3/"/>
    <url>/2024/06/27/python%E6%97%B6%E9%97%B4%E6%88%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="Python常见函数之-Python-时间戳"><a href="#Python常见函数之-Python-时间戳" class="headerlink" title="Python常见函数之 Python 时间戳"></a>Python常见函数之 Python 时间戳</h1><p>来自百度百科： 时间戳，是指用户应用数字签名技术时，产生的涵盖原始文件信息、签名时间、签名参数等信息。 其主要目的是在于，能够通过一定的技术手段认证数据产生的时间，从而得知这段数据在产生之后，是否有被篡改。</p><p>个人目前接触到使用领域：在做全球化产品的时候依赖于时间戳在不同时区进行展示</p><h2 id="time-时间戳等相关转换"><a href="#time-时间戳等相关转换" class="headerlink" title="time 时间戳等相关转换"></a>time 时间戳等相关转换</h2><h3 id="datetime与时间戳格式相互转换"><a href="#datetime与时间戳格式相互转换" class="headerlink" title="datetime与时间戳格式相互转换"></a>datetime与时间戳格式相互转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 将datetime转换为unix时间戳</span><br>dtime = datetime.date.today()<br>unix_time = time.mktime(dtime.timetuple())<br><span class="hljs-built_in">print</span>(dtime, unix_time)   <span class="hljs-comment"># 2019-09-02 1567353600.0</span><br><br><span class="hljs-comment"># 将unix时间戳转换成datetime</span><br>dtime2 = datetime.datetime.fromtimestamp(unix_time)<br><span class="hljs-built_in">print</span>(dtime2)<br><span class="hljs-number">1234567891011</span><br></code></pre></td></tr></table></figure><h3 id="根据时间差获得时间"><a href="#根据时间差获得时间" class="headerlink" title="根据时间差获得时间"></a>根据时间差获得时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">yestoday = datetime.date.today() + datetime.timedelta(days=-<span class="hljs-number">1</span>)  <span class="hljs-comment"># days=-1，代表昨天，-2代表前天，1代表明天...</span><br></code></pre></td></tr></table></figure><h3 id="datetime-格式与字符串格式的相互转换"><a href="#datetime-格式与字符串格式的相互转换" class="headerlink" title="datetime 格式与字符串格式的相互转换"></a>datetime 格式与字符串格式的相互转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># datetime 格式与字符串格式的相互转换</span><br>today_str =datetime.date.today().strftime(<span class="hljs-string">&quot;%Y-%m-%d&quot;</span>)  <span class="hljs-comment"># 转换为字符串</span><br>today_datetime = datetime.datetime.strptime(<span class="hljs-string">&quot;2019-09-01 00:00:00&quot;</span>, <span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)  <span class="hljs-comment"># 转换为datetime</span><br><span class="hljs-built_in">print</span>(today_str,<span class="hljs-built_in">type</span>(today_str)) <br><span class="hljs-built_in">print</span>(today_datetime,<span class="hljs-built_in">type</span>(today_datetime))<br><span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><h3 id="定时时间表"><a href="#定时时间表" class="headerlink" title="定时时间表"></a>定时时间表</h3><p>比如获得24个小时的列表（以下是每隔半个小时）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_time_list</span>(<span class="hljs-params">self</span>):<br>     start_time = datetime.datetime.strptime(<span class="hljs-string">&quot;2019-08-28 14:00:00&quot;</span>, <span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)<br>     unix_start_time = time.mktime(start_time.timetuple())  <span class="hljs-comment"># 转换成时间戳</span><br>     un_timelist = [(unix_start_time+i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">86400</span>+<span class="hljs-number">1</span>, <span class="hljs-number">1800</span>)]  <br>     timelist = [datetime.datetime.fromtimestamp(un_time) <span class="hljs-keyword">for</span> un_time <span class="hljs-keyword">in</span> un_timelist]  <span class="hljs-comment"># 再转换成datetime格式</span><br>     <span class="hljs-keyword">return</span> timelist<br></code></pre></td></tr></table></figure><h3 id="各个级别的时间戳获取"><a href="#各个级别的时间戳获取" class="headerlink" title="各个级别的时间戳获取"></a>各个级别的时间戳获取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> datetime<br><br>original=time.time()   <span class="hljs-comment"># 原始时间戳</span><br>Secondlevel =<span class="hljs-built_in">int</span>(original)       <span class="hljs-comment"># 秒级别时间戳</span><br>millisecondlevel=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">round</span>(original*<span class="hljs-number">1000</span>)   <span class="hljs-comment"># 毫秒级别时间戳</span><br>microsecondlevel=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">round</span>(original*<span class="hljs-number">1000000</span>)  <span class="hljs-comment"># 微秒级别时间戳</span><br></code></pre></td></tr></table></figure><h3 id="毫秒级别时间戳转换时间"><a href="#毫秒级别时间戳转换时间" class="headerlink" title="毫秒级别时间戳转换时间"></a>毫秒级别时间戳转换时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timeStamp</span>(<span class="hljs-params">timeNum</span>):<br>    timeStamp = <span class="hljs-built_in">float</span>(timeNum / <span class="hljs-number">1000</span>)<br>    timeArray = time.localtime(timeStamp)<br>    otherStyleTime = time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, timeArray)<br>    <span class="hljs-built_in">print</span>(otherStyleTime)<br><br><br>timeStamp(<span class="hljs-number">1622674800000</span>)  <span class="hljs-comment"># 2021-06-02 23:00:00</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python 常见函数</category>
      
      <category>Python 时间戳函数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
      <tag>python 时间戳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年第二次在北京参加油车摇号</title>
    <link href="/2024/06/27/%E9%9A%8F%E7%AC%94/"/>
    <url>/2024/06/27/%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h1 id="2024年第二次在北京参加油车摇号"><a href="#2024年第二次在北京参加油车摇号" class="headerlink" title="2024年第二次在北京参加油车摇号"></a>2024年第二次在北京参加油车摇号</h1><p>我是从2023年才满足了参加北京摇号的资格，两次结果可能不用想也知道没中，看着北京摇号贴吧哪些人在疯狂吐槽这些摇号政策，我心里只想哎，这破京牌有啥用！</p><p>然后转头就许愿 2024下半年让我中！😂😂😂</p><img src="/2024/06/27/%E9%9A%8F%E7%AC%94/%E4%B8%AD%E7%AD%BE.jpeg" class="">]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>2024年随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>随笔</tag>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常见函数之 is和==的区别</title>
    <link href="/2024/06/27/is%E5%92%8C==%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/06/27/is%E5%92%8C==%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="python-常见函数之-is-与-的区别"><a href="#python-常见函数之-is-与-的区别" class="headerlink" title="python 常见函数之 is 与 &#x3D;&#x3D; 的区别"></a>python 常见函数之 is 与 &#x3D;&#x3D; 的区别</h1><h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><p>is 比较 id()</p><h2 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h2><p>&#x3D;&#x3D; 比较 变量值</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># is, 本质 id(a) 与 id(b) 比较</span><br><span class="hljs-comment"># = 右边为对象时，表示生成新对象 </span><br><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <br>b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <br><span class="hljs-built_in">print</span>(a <span class="hljs-keyword">is</span> b)   <span class="hljs-comment"># False, 说明 id 不同</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a), <span class="hljs-built_in">id</span>(b))<br><span class="hljs-built_in">print</span>(a == b)   <span class="hljs-comment"># True, 值相同，内部 __eq__ 魔法函数</span><br><br><span class="hljs-comment"># 小整数、小字符串 全局唯一 intern机制</span><br><br>a1 = <span class="hljs-number">1</span> a2 = <span class="hljs-number">1</span> <br><span class="hljs-built_in">print</span>(a1 <span class="hljs-keyword">is</span> a2)     <span class="hljs-comment"># True  </span><br>s1 = <span class="hljs-string">&#x27;abc&#x27;</span> <br>s2 = <span class="hljs-string">&#x27;abc&#x27;</span> <br><span class="hljs-built_in">print</span>(s1 <span class="hljs-keyword">is</span> s2)     <span class="hljs-comment"># True</span><br><br><span class="hljs-comment"># 类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>:    <br>    <span class="hljs-keyword">pass</span>   <br><br><span class="hljs-comment"># People 全局唯一 </span><br>person = People() <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(person) <span class="hljs-keyword">is</span> People)   <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python 常见函数</category>
      
      <category>Python is和==的区别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python常见函数之 isinstance和type的区别</title>
    <link href="/2024/06/27/isinstance%E5%92%8Ctype%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/06/27/isinstance%E5%92%8Ctype%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="python常见函数之-isinstance和type的区别"><a href="#python常见函数之-isinstance和type的区别" class="headerlink" title="python常见函数之 isinstance和type的区别"></a>python常见函数之 isinstance和type的区别</h1><h2 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a>isinstance</h2><p>isinstance 会去查找继承链</p><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>type 只判断变量的内存地址</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">pass</span><br><br>b = B()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(b, B)) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(b, A)) <span class="hljs-comment"># True</span><br><br><span class="hljs-comment"># is 判断 id 的意思</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(b) <span class="hljs-keyword">is</span> B) <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(b) <span class="hljs-keyword">is</span> A)     <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python 常见函数</category>
      
      <category>Python isinstance和type的区别</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jmeter 切换语言</title>
    <link href="/2024/06/26/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7JMETER/"/>
    <url>/2024/06/26/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7JMETER/</url>
    
    <content type="html"><![CDATA[<h1 id="Jmeter-介绍"><a href="#Jmeter-介绍" class="headerlink" title="Jmeter 介绍"></a>Jmeter 介绍</h1><p>Jmeter 是一款优秀的性能测试工具，是通过java开发，这里简单的安装过程不在介绍，主要介绍一下使用技巧。</p><h2 id="切换语言"><a href="#切换语言" class="headerlink" title="切换语言"></a>切换语言</h2><p>可以通过单击options-&gt;Choose Language来选择语言</p><img src="/2024/06/26/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7JMETER/Jmeter%E5%88%87%E6%8D%A2%E8%AF%AD%E8%A8%80.png" class="">]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Jmeter</category>
      
      <category>Jmeter 切换语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Jmeter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fiddler之面板信息介绍</title>
    <link href="/2024/06/26/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Fiddler/"/>
    <url>/2024/06/26/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Fiddler/</url>
    
    <content type="html"><![CDATA[<h1 id="Fillder"><a href="#Fillder" class="headerlink" title="Fillder"></a>Fillder</h1><p>Fillder是一款优秀的抓包软件，不管是在windows，linux， mac下都可以使用！关于基本的安装这边就跳过了，下面我们主要来看一下使用过程中的一些技巧</p><h2 id="Fillder-面板信息组成"><a href="#Fillder-面板信息组成" class="headerlink" title="Fillder 面板信息组成"></a>Fillder 面板信息组成</h2><img src="/2024/06/26/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Fiddler/fillder%E9%9D%A2%E6%9D%BF%E7%BB%84%E6%88%90%E4%BF%A1%E6%81%AF.png" class=""><h3 id="HTTP报文总体介绍"><a href="#HTTP报文总体介绍" class="headerlink" title="HTTP报文总体介绍"></a>HTTP报文总体介绍</h3><p>HTTP协议报文的结构</p><p>HTTP报文分2个：一个是HTTP请求报文，一个是HTTP响应报文</p><p>HTTP请求报文分为3部分：第一部分叫其实行(Request line),第二部分叫首部（Request Header),第三部分叫主体(Body)</p><p>第一行中Method表示请求方法，比如“POST”或者“GET”现在使用的HTTP协议版本是1.1</p><p>第二部分是首部（Header)</p><p>第三部分是body</p><p>特别要注意，Header与Body之间有一个空行</p><h3 id="Fillder-请求界面"><a href="#Fillder-请求界面" class="headerlink" title="Fillder 请求界面"></a>Fillder 请求界面</h3><img src="/2024/06/26/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Fiddler/fillder%E8%AF%B7%E6%B1%82%E7%95%8C%E9%9D%A2.png" class=""><h3 id="Fillder-响应界面"><a href="#Fillder-响应界面" class="headerlink" title="Fillder 响应界面"></a>Fillder 响应界面</h3><img src="/2024/06/26/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Fiddler/fillder%E5%93%8D%E5%BA%94%E7%95%8C%E9%9D%A2.png" class=""><h3 id="HTTP协议请求方法和状态码"><a href="#HTTP协议请求方法和状态码" class="headerlink" title="HTTP协议请求方法和状态码"></a>HTTP协议请求方法和状态码</h3><p>HTTP协议定义了很多与服务器交互的方法，最基本有5种，分别是GET HEAD POST PUT DELETE。对应的就是查改增删的4个操作，最常见的是POST和GET，GET一般用于获取&#x2F;查询资源信息，而POST一般用于更新资源信息。</p><p>GET和POST方法的区别</p><p>GET提交的数据会放在URL之后，以问号（？）分割URL和传输数据，参数之间以&amp;相连，而POST是把提交的数据放在HTTP包的Body中</p><p>GET提交数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据大小没有限制</p><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方法通过Request.Form来获取变量的值</p><p>GET方式提交数据会带来安全问题，比如登录一个页面通过GET的方式提交数据时候，用户名和密码都会显示在URL中，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码</p><h3 id="HTTP-报文响应介绍"><a href="#HTTP-报文响应介绍" class="headerlink" title="HTTP 报文响应介绍"></a>HTTP 报文响应介绍</h3><p>Response消息的结构和Request消息的结构基本一样，同样也分为3部分；第一部分叫响应行（Response Line)，第二部分叫响应首部（Response Header)，第三部分是主体(Body)</p><p>第一部分是起始行，有状态码和状态码消息</p><p>第二部分是首部，</p><p>第三部分是主体</p><p>特别注意 Header首部和Body(主体)之间有一个空行</p><h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><table><thead><tr><th>状态码</th><th>已定义范围</th><th>分类</th></tr></thead><tbody><tr><td>1XX</td><td>100-101</td><td>信息提示：表示请求已成功接收、继续处理</td></tr><tr><td>2XX</td><td>200-206</td><td>成功、表示请求已被成功接收，理解、接受</td></tr><tr><td>3XX</td><td>300-305</td><td>重定向，完成请求，必须进行更进一步的处理</td></tr><tr><td>4XX</td><td>400-415</td><td>客户端错误，请求有语法错误或者无法实现请求</td></tr><tr><td>5XX</td><td>500-505</td><td>服务器错误，服务器未能实现合法的请求</td></tr></tbody></table><h4 id="HTTP-协议Header介绍"><a href="#HTTP-协议Header介绍" class="headerlink" title="HTTP 协议Header介绍"></a>HTTP 协议Header介绍</h4><p>Header的语法格式是”key:value”，一行一个Header。每一个Header都有特殊的作用，在Finddler中可以查看完整的Header。</p><p>Fiddler能方便的查看HTTP请求Header,选中一个HTTP请求，单击Inspectors tab–&gt;Request tab–&gt;Headers</p><h4 id="Cache相关的Header"><a href="#Cache相关的Header" class="headerlink" title="Cache相关的Header"></a>Cache相关的Header</h4><h5 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h5><p>Cookie是一种HTTP Header,是HTTP中非常重要的内容，它由key&#x3D;&#x3D;value形式组成</p><p>Accept</p><p>Accept表示浏览器客户端可以接受的媒体类型</p><p>例如 Accept:text&#x2F;html代表浏览器可以接受服务器返回html，也就是我们通常说的html文档。</p><p>通配符&#x2F;*代表任意类型，\<em>&#x2F;\</em>表示可以接受任何类型。</p><h5 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h5><p>Accept-Encoding跟压缩有关，浏览器发送HTTP请求给web服务器，HTTP请求中的Header有Accept-Encoding:gizp,deflate(告诉服务器，浏览器支持gizp压缩)</p><h5 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h5><p>Accept-Language的作用是声明自己接受的语言</p><p>也就是编码格式 UTF-8 GB2312 ZH-CN</p><h5 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h5><p>Use-Agent的作用是浏览器用来告诉服务器，客户端使用的操作系统及版本，CPU类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件</p><p>修改User-Agent可以伪装不同的客户端</p><img src="/2024/06/26/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Fiddler/fillder%E4%BF%AE%E6%94%B9Useragent.png" class=""><p>单击Rules-&gt;User-Agents然后可以选择我们想要切换的系统</p><h5 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h5><p>HTTP协议头中的Refer主要来让服务器来判断来源页面，即用户是从哪个页面过来的网站通常用来统计用户的来源，看用户是从搜索页面来的，还是从其他网站链接过来的，或是从书签等访问过来的，以便合理的定位网站</p><p>Referer有时也被用作防盗链，即下载时候判断来源地址是不是在网站域名之内，否则就不能下载或显示</p><h5 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h5><p>从HTTP1.1起，系统默认开启了Connection:Keep-Alive，保持连接特性</p><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><p>主要是指定被请求的主机端口号，它通常从HTTP URL中提取出来</p><p>Web网页抓包和fiddler修改包</p><p>通过fiddler可以修改数据伪造数据</p><p>第一个HTTP请求是获取页面布局的HTML 也叫做“父请求”</p><p>随后的HTTP请求会根据之前页面的请求去再次请求，叫做“子请求”</p><img src="/2024/06/26/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7Fiddler/%E7%88%B6%E5%AD%90%E8%AF%B7%E6%B1%82.png" class=""><p>选中我们的第一个父请求然后右击选择seletc–&gt;Child Request 就可以找到对应的子</p><p>找父请求的话我们选中子子请求右击选择select-&gt;Parent Request就可以找到对应的父请求。</p><p>查找相同的请求，右击选择select–&gt;Duplicate Requests就可以选中了相同的请求了。</p>]]></content>
    
    
    <categories>
      
      <category>测试开发工具/框架</category>
      
      <category>Fillder</category>
      
      <category>Fillder 面板信息介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>Fillder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python常见函数之 Python 切片操作详解</title>
    <link href="/2024/06/25/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/06/25/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Python常见函数之-Python-切片操作详解"><a href="#Python常见函数之-Python-切片操作详解" class="headerlink" title="Python常见函数之 Python 切片操作详解"></a>Python常见函数之 Python 切片操作详解</h1><p>在 Python 中，切片（slicing）是一种强大的工具，它允许我们访问序列类型（如列表、元组、字符串等）中的一部分元素。切片的基本语法是 <code>[start:stop:step]</code>，其中 <code>start</code> 是起始索引（包含），<code>stop</code> 是结束索引（不包含），<code>step</code> 是步长。  </p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>第一个数字 start 表示切片开始位置，默认 0</p><p>第二个数字 end 表示切片截止(但不包含)位置，默认列表长度</p><p>第三个数字 step 表示切片的步骤，默认为 1</p><p>当 start 为 0 时可以省略</p><p>当 end 为列表长度时可以省略</p><p>当 step 为 1 时可以省略，并且省略步长时可以同时省略最后一个冒号</p><p>当 step 为负数时，表示反向切片，这时 start 应该比 end 的值要大才行</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">a_list = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>]<br><br>a_list[::]      <span class="hljs-comment"># 返回包含原列表中所有元素的新列表</span><br><br>a_list[::-<span class="hljs-number">1</span>]    <span class="hljs-comment"># 返回包含原列表中所有元素的逆向新列表</span><br><br>a_list[::<span class="hljs-number">2</span>]     <span class="hljs-comment"># 隔一个元素取一个，获取偶数位置的元素</span><br><br>a_list[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]    <span class="hljs-comment"># 隔一个元素取一个，获取奇数位置的元素</span><br><br>a_list[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>]     <span class="hljs-comment"># 指定切片的开始和结束位置</span><br><br>a_list[<span class="hljs-number">0</span>:<span class="hljs-number">100</span>]   <span class="hljs-comment"># 切片结束位置大于列表长度是，从列表尾部截断</span><br><br>a_list[<span class="hljs-number">100</span>:]    <span class="hljs-comment"># 切片开始位置大于列表长度时，返回空列表</span><br><br><br><br>a_list[<span class="hljs-built_in">len</span>(a_list):<span class="hljs-number">0</span>] = [<span class="hljs-number">9</span>]     <span class="hljs-comment"># 在列表尾部增加元素</span><br><br>a_list[:<span class="hljs-number">0</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]             <span class="hljs-comment"># 在列表头部增加元素</span><br><br>a_list[<span class="hljs-number">3</span>:<span class="hljs-number">3</span>] = [<span class="hljs-number">100</span>]             <span class="hljs-comment"># 在列表中间位置插入元素</span><br><br>a_list[:<span class="hljs-number">2</span>] = [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>]         <span class="hljs-comment"># 替换列表元素，等号两边长度相等</span><br><br>a_list[<span class="hljs-number">3</span>:] = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]          <span class="hljs-comment"># 替换列表元素，等号两边长度可以不相等</span><br><br>a_list[:<span class="hljs-number">3</span>] = []                 <span class="hljs-comment"># 删除列表中前 3 个元素</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Python 常见函数</category>
      
      <category>Python 常见切片操作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
